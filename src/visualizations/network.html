<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>Mutual Recognitionholding Visualization</title>
    <script src="https://d3js.org/d3.v6.min.js"></script>
    <style>
      body {
        font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
        margin: 0;
        padding: 0;
        background-color: #f5f5f5;
        overflow: hidden;
      }
      
      .header {
        position: absolute;
        top: 10px;
        left: 0;
        right: 0;
        text-align: center;
        pointer-events: none;
        z-index: 100;
      }
      
      h1 {
        font-size: 24px;
        margin: 0;
        color: #333;
        text-shadow: 0 1px 2px rgba(255,255,255,0.8);
      }
      
      .subtitle {
        font-size: 14px;
        color: #666;
        margin-top: 5px;
      }
      
      .control-panel {
        position: absolute;
        bottom: 20px;
        left: 0;
        right: 0;
        display: flex;
        justify-content: center;
        gap: 15px;
        background-color: rgba(255,255,255,0.8);
        padding: 10px;
        border-radius: 10px;
        margin: 0 auto;
        width: fit-content;
      }
      
      .control-button {
        display: flex;
        flex-direction: column;
        align-items: center;
        cursor: pointer;
      }
      
      .button-circle {
        width: 40px;
        height: 40px;
        border-radius: 50%;
        transition: all 0.3s ease;
        display: flex;
        align-items: center;
        justify-content: center;
        margin-bottom: 5px;
        box-shadow: 0 2px 5px rgba(0,0,0,0.2);
      }
      
      .button-circle:hover {
        transform: scale(1.1);
        box-shadow: 0 4px 8px rgba(0,0,0,0.3);
      }
      
      .button-label {
        font-size: 12px;
        color: #333;
      }
      
      .slider {
        background-color: rgba(255,255,255,0.8);
        padding: 3px;
        border-radius: 5px;
        box-shadow: 0 1px 3px rgba(0,0,0,0.1);
        display: none; /* Hide sliders by default as we're replacing them */
      }
      
      .slider input {
        width: 100%;
      }
      
      .slider label {
        font-size: 10px;
        white-space: nowrap;
      }
      
      .legend {
        position: absolute;
        top: 20px;
        right: 20px;
        background-color: rgba(255,255,255,0.8);
        padding: 10px;
        border-radius: 5px;
        box-shadow: 0 2px 5px rgba(0,0,0,0.2);
        z-index: 100;
      }
      
      .legend-item {
        display: flex;
        align-items: center;
        margin-bottom: 5px;
      }
      
      .legend-color {
        width: 15px;
        height: 15px;
        border-radius: 50%;
        margin-right: 8px;
      }
      
      .network-name {
        font-weight: bold;
        text-shadow: 0px 0px 3px rgba(255,255,255,0.5);
      }
      
      /* Add tooltip styles */
      .tooltip {
        position: absolute;
        background-color: rgba(0,0,0,0.7);
        color: white;
        padding: 5px 10px;
        border-radius: 4px;
        font-size: 12px;
        pointer-events: none;
        opacity: 0;
        transition: opacity 0.3s;
        z-index: 1000;
      }
      
      /* Add styles for slice interaction */
      .pie-slice {
        cursor: pointer;
        transition: opacity 0.2s;
      }
      
      .pie-slice:hover {
        opacity: 0.8;
      }
      
      .pie-slice.active {
        stroke: #fff;
        stroke-width: 2px;
      }
      
      .click-instruction {
        position: absolute;
        top: 70px;
        left: 0;
        right: 0;
        text-align: center;
        color: #666;
        font-size: 14px;
        pointer-events: none;
      }
    </style>
  </head>
  <body>
    <div class="header">
      <h1>Mutual Recognition Network</h1>
      <div class="subtitle">Visualizing inter-network relationships and value flows</div>
    </div>
    
    <div class="tooltip"></div>
    
    <script>
      const svgGroups = {};
      // Add a global variable to track nested chart visibility
      let nestedChartsVisible = false;

      const networks = {
        DanceParty: {
          id: "DanceParty",
          // should transition to asset/liabilities and denomination as main categories.
          recognitions: [
            { id: "Luminations", value: 20, denomination: "DanceParty" },
            { id: "Gardening", value: 30, denomination: "DanceParty" },
            { id: "Diagrams", value: 30, denomination: "DanceParty" },
            { id: "Pizza", value: 20, denomination: "DanceParty" },
          ],
          style: {
            color: "#4caf50",
          },
          surplus: [
            { id: "Book NFT", style: { color: "#3f51b5", fontSize: "12px" } },
            { id: "swag", style: { color: "#9c27b0", fontSize: "12px" } },
            { id: "Gear", style: { color: "#e91e63", fontSize: "12px" } },
          ],
        },
        Luminations: {
          id: "Luminations",
          recognitions: [
            { id: "DanceParty", value: 40, denomination: "Luminations" },
            { id: "Diagrams", value: 60, denomination: "Luminations" },
          ],
          style: {
            color: "#ff9800",
          },
          surplus: [
            { id: "Games", style: { color: "#f44336", fontSize: "12px" } },
            { id: "Play", style: { color: "#e91e63", fontSize: "12px" } },
          ],
        },
        Gardening: {
          id: "Gardening",
          recognitions: [
            { id: "DanceParty", value: 70, denomination: "Gardening" },
            { id: "Luminations", value: 30, denomination: "Gardening" },
          ],
          style: {
            color: "#2196f3",
          },
          surplus: [
            { id: "Rights", style: { color: "#4caf50", fontSize: "12px" } },
            {
              id: "Obligations",
              style: { color: "#ffeb3b", fontSize: "12px" },
            },
          ],
        },
        Diagrams: {
          id: "Diagrams",
          recognitions: [
            { id: "DanceParty", value: 60, denomination: "Diagrams" },
            { id: "Luminations", value: 30, denomination: "Diagrams" },
          ],
          style: {
            color: "#8824ff",
          },
          surplus: [
            { id: "Rights", style: { color: "#4caf50", fontSize: "12px" } },
            {
              id: "Obligations",
              style: { color: "#ffeb3b", fontSize: "12px" },
            },
          ],
        },
        Pizza: {
          id: "Pizza",
          recognitions: [
            { id: "DanceParty", value: 70, denomination: "Diagrams" },
            { id: "Luminations", value: 30, denomination: "Diagrams" },
          ],
          style: {
            color: "#fff624",
          },
          surplus: [
            { id: "Rights", style: { color: "#4caf50", fontSize: "12px" } },
            {
              id: "Obligations",
              style: { color: "#ffeb3b", fontSize: "12px" },
            },
          ],
        },
      };

      function generateGraphData() {
        return {
          nodes: Object.keys(networks).map((key) => ({
            id: key,
            style: networks[key].style,
          })),
          links: Object.keys(networks).flatMap((key) =>
            networks[key].recognitions
              .filter((recognition) => recognition.value !== 0)
              .map((recognition) => ({
                source: key,
                target: recognition.id,
                value: recognition.value,
                denomination: recognition.denomination,
              }))
          ),
        };
      }

      /*
 ▐ ▄ ▄▄▄ .▄▄▄▄▄▄▄▌ ▐ ▄▌      ▄▄▄  ▄ •▄
•█▌▐█▀▄.▀·•██  ██· █▌▐█▪     ▀▄ █·█▌▄▌▪
▐█▐▐▌▐▀▀▪▄ ▐█.▪██▪▐█▐▐▌ ▄█▀▄ ▐▀▀▄ ▐▀▀▄·
██▐█▌▐█▄▄▌ ▐█▌·▐█▌██▐█▌▐█▌.▐▌▐█•█▌▐█.█▌
▀▀ █▪ ▀▀▀  ▀▀▀  ▀▀▀▀ ▀▪ ▀█▄▀▪.▀  ▀·▀  ▀
*/

      function addNetwork(networkId) {
        networks[networkId] = {
          id: networkId,
          recognitions: [],
          style: {},
          surplus: [],
          svgGroup: undefined,
        };
      }

      function addRecognition(networkId, denomination, quantity) {
        networks[networkId].recognitions.push({
          denomination: denomination,
          qauntity: quantity,
        });
      }

      function addSurplus(
        networkId,
        denomination,
        quantity,
        divisible = Boolean,
        style
      ) {
        networks[networkId].surplus.push({
          denomination: denomination,
          quantity: quantity,
          divisible: divisible,
          style: style,
        });
      }

      /*
.▄▄ · ▄▄▄▄▄ ▄▄▄· ▄ •▄ ▄▄▄ .
▐█ ▀. •██  ▐█ ▀█ █▌▄▌▪▀▄.▀·
▄▀▀▀█▄ ▐█.▪▄█▀▀█ ▐▀▀▄·▐▀▀▪▄
▐█▄▪▐█ ▐█▌·▐█ ▪▐▌▐█.█▌▐█▄▄▌
 ▀▀▀▀  ▀▀▀  ▀  ▀ ·▀  ▀ ▀▀▀
*/

      const recognitionChart = d3
        .pie()
        .sort(null)
        .value((d) => d.value);

      const arcGenerator = d3.arc().innerRadius(0).outerRadius(75);

      const colorScale = d3
        .scaleOrdinal()
        .domain(Object.keys(networks))
        .range(Object.values(networks).map((p) => p.style.color));

      function updateRecognitionChart(svgGroup, networkId) {
        const data = networks[networkId].recognitions.map((s) => ({
          label: `Recognition in ${s.id}`,
          value: s.value,
          nestedRecognition: s.id,
          networkId: networkId,
          recognitionId: s.id
        }));

        const arcs = recognitionChart(data);

        const mainPaths = svgGroup.selectAll("path").data(arcs);
        mainPaths
          .enter()
          .append("path")
          .attr("class", "pie-slice")
          .merge(mainPaths)
          .attr("d", arcGenerator)
          .attr("fill", (d) => colorScale(d.data.nestedRecognition))
          // Add tooltip for slices
          .on("mouseover", function(event, d) {
            tooltip
              .style("opacity", 1)
              .html(`Recognition of ${d.data.recognitionId}: ${Math.round(d.data.value)}%`)
              .style("left", (event.pageX + 10) + "px")
              .style("top", (event.pageY - 10) + "px");
          })
          .on("mouseout", function() {
            tooltip.style("opacity", 0);
          })
          // Add interaction events
          .on("mousedown", function(event, d) {
            event.stopPropagation();
            d3.select(this).classed("active", true);
            
            // Store the current slice being adjusted
            window.activeSlice = {
              element: this,
              data: d.data,
              increasing: true, // By default, increase the value
              interval: setInterval(() => {
                updateSliceValue(d.data.networkId, d.data.recognitionId, window.activeSlice.increasing);
              }, 100) // Update every 100ms
            };
            
            // Add event to document to detect right-click (decrease)
            d3.select(document).on("contextmenu.slice", function(event) {
              event.preventDefault();
              if (window.activeSlice) {
                window.activeSlice.increasing = false;
              }
            });
          })
          .on("mouseup mouseleave", function() {
            clearActiveSlice();
          });
        
        mainPaths.exit().remove();

        updateNestedCharts(svgGroup, arcs);
      }
      
      // Function to update a slice value
      function updateSliceValue(networkId, recognitionId, isIncrease) {
        const recognition = networks[networkId].recognitions.find(
          (s) => s.id === recognitionId
        );
        
        if (isIncrease) {
          // Increase this slice and proportionally decrease others
          const otherRecognitions = networks[networkId].recognitions.filter(s => s.id !== recognitionId);
          const totalOtherValues = otherRecognitions.reduce((sum, rec) => sum + rec.value, 0);
          
          if (totalOtherValues > 10) { // Keep some minimum value in other slices
            // Increase by 1%
            recognition.value += 1;
            
            // Proportionally decrease others
            otherRecognitions.forEach(rec => {
              const proportion = rec.value / totalOtherValues;
              rec.value = Math.max(1, rec.value - 1 * proportion);
            });
            
            // Normalize to ensure total is 100
            const total = networks[networkId].recognitions.reduce((sum, rec) => sum + rec.value, 0);
            networks[networkId].recognitions.forEach(rec => {
              rec.value = (rec.value / total) * 100;
            });
          }
        } else {
          // Decrease this slice and proportionally increase others
          if (recognition.value > 10) { // Keep some minimum value
            // Decrease by 1%
            recognition.value -= 1;
            
            // Proportionally increase others
            const otherRecognitions = networks[networkId].recognitions.filter(s => s.id !== recognitionId);
            const totalOtherValues = otherRecognitions.reduce((sum, rec) => sum + rec.value, 0);
            
            otherRecognitions.forEach(rec => {
              const proportion = rec.value / totalOtherValues;
              rec.value += 1 * proportion;
            });
            
            // Normalize to ensure total is 100
            const total = networks[networkId].recognitions.reduce((sum, rec) => sum + rec.value, 0);
            networks[networkId].recognitions.forEach(rec => {
              rec.value = (rec.value / total) * 100;
            });
          }
        }
        
        // Update the visualization
        updateAllCharts();
      }
      
      // Function to clear the active slice
      function clearActiveSlice() {
        if (window.activeSlice) {
          clearInterval(window.activeSlice.interval);
          d3.select(window.activeSlice.element).classed("active", false);
          window.activeSlice = null;
          d3.select(document).on("contextmenu.slice", null);
        }
      }
      
      // Function to update all charts
      function updateAllCharts() {
        Object.keys(networks).forEach((networkId) => {
          const svgGroup = svgGroups[networkId];
          updateRecognitionChart(svgGroup, networkId);
        });
        
        // Also update the links to reflect the new values
        updateLinks();
      }
      
      // Function to update the links between networks
      function updateLinks() {
        // Update graph data with new recognition values
        let newGraphData = generateGraphData();
        
        // Select all links and update their widths
        d3.selectAll(".links path")
          .data(newGraphData.links)
          .attr("stroke-width", (d) => d.value);
      }

      function updateNestedCharts(svgGroup, arcs) {
        // Remove any existing nested charts first
        svgGroup.selectAll(".nested-chart").remove();
        
        // Only create nested charts if they should be visible
        if (nestedChartsVisible) {
          arcs.forEach((arc) => {
            const nestedData = networks[arc.data.nestedRecognition].recognitions.map((s) => ({
              label: `Recognition in ${s.id}`,
              value: s.value,
            }));

            const angle = arc.endAngle - arc.startAngle;
            const nestedRadius = (75 / 4) * Math.sqrt((2 * angle) / Math.PI);

            const nestedArcGenerator = d3
              .arc()
              .innerRadius(0)
              .outerRadius(nestedRadius);

            const nestedSvgGroup = svgGroup
              .append("g")
              .attr("class", "nested-chart") // Add a class for easy selection
              .attr("transform", `translate(${arcGenerator.centroid(arc)})`);

            const nestedArcs = recognitionChart(nestedData);
            const nestedPaths = nestedSvgGroup.selectAll("path").data(nestedArcs);
            nestedPaths
              .enter()
              .append("path")
              .merge(nestedPaths)
              .attr("d", nestedArcGenerator)
              .attr("fill", (d) => colorScale(d.data.label.split(" ")[2]));
            nestedPaths.exit().remove();
          });
        }
      }

      function createNetworkGraph() {
        const width = window.innerWidth;
        const height = window.innerHeight;
        let graphData = generateGraphData();

        // Create tooltip
        const tooltip = d3.select(".tooltip");
        
        // Add instruction for click-and-hold
        d3.select("body")
          .append("div")
          .attr("class", "click-instruction")
          .html("Click and hold on a slice to increase its size. Right-click to decrease.");

        const svg = d3
          .select("body")
          .append("svg")
          .attr("width", width)
          .attr("height", height)
          .style("display", "block")
          .style("margin", "0 auto");
          
        // Add zoom behavior
        const zoom = d3.zoom()
          .scaleExtent([0.5, 3])
          .on("zoom", (event) => {
            container.attr("transform", event.transform);
          });
          
        svg.call(zoom);
          
        // Create a container for all elements that will be zoomed
        const container = svg.append("g");

        const generateLinkPath = (s, t) => {
          return `M${s.x},${s.y} L${t.x},${t.y}`;
        };

        const link = container
          .append("g")
          .attr("class", "links")
          .selectAll("path")
          .data(graphData.links)
          .enter()
          .append("path")
          .attr("id", (_, i) => `link-${i}`)
          .attr("stroke", "black")
          .attr("stroke-opacity", 0.6)
          .attr("stroke-width", (d) => d.value)
          .attr("fill", "none");

        const surplus = container
          .append("g")
          .attr("class", "surplus")
          .selectAll("circle")
          .data(
            graphData.links.flatMap((link) =>
              networks[link.source].surplus.map((surplus) => ({
                source: link.source,
                target: surplus.id,
              }))
            )
          )
          .enter()
          .append("circle")
          .attr("cx", (d) => d.source.x) // Set initial x position
          .attr("cy", (d) => d.source.y) // Set initial y position
          .attr("r", 10)
          .each(function (d, i) {
            d3.select(this)
              .append("animateMotion")
              .attr("dur", "5s")
              .attr("repeatCount", "indefinite")
              .attr("begin", `${(i / graphData.links.length) * 5}s`)
              .append("mpath")
              .attr("href", `#link-${i}`);
          });

        surplus.attr("fill", (d) => {
          const sourceNetwork = networks[d.source];
          const surplusIndex = sourceNetwork.surplus.findIndex(
            (surplus) => surplus.id === d.target
          );
          return sourceNetwork.surplus[surplusIndex].style.color;
        })
        .on("mouseover", function(event, d) {
          tooltip
            .style("opacity", 1)
            .html(`Surplus: ${d.target}`)
            .style("left", (event.pageX + 10) + "px")
            .style("top", (event.pageY - 10) + "px");
        })
        .on("mouseout", function() {
          tooltip.style("opacity", 0);
        });

        const node = container
          .append("g")
          .attr("class", "nodes")
          .selectAll("g")
          .data(graphData.nodes)
          .enter()
          .append("g");

        node.each(function (d) {
          const networkId = d.id;
          const svgGroup = d3
            .select(this)
            .append("svg")
            .attr("width", 200)
            .attr("height", 200)
            .append("g")
            .attr("transform", "translate(100, 100)");
          svgGroups[networkId] = svgGroup; // Store the svg group
          updateRecognitionChart(svgGroup, networkId);

          // Add the label inside the circle
          svgGroup
            .append("text")
            .attr("x", 0)
            .attr("y", 85)
            .attr("class", "network-name") // Add a class for easy selection
            .text(networkId)
            .style("font-size", "12px")
            .style("text-anchor", "middle")
            .style("alignment-baseline", "middle");

          // Append a circle around the pie chart
          svgGroup
            .append("circle")
            .attr("cx", 0)
            .attr("cy", 0)
            .attr("r", 95)
            .attr("fill", "none")
            .attr("stroke", d.style.color)
            .attr("stroke-width", 3);
          
          // Add hover effect to show details
          d3.select(this)
            .on("mouseover", function(event, d) {
              tooltip
                .style("opacity", 1)
                .html(`Network: ${d.id}`)
                .style("left", (event.pageX + 10) + "px")
                .style("top", (event.pageY - 10) + "px");
            })
            .on("mouseout", function() {
              tooltip.style("opacity", 0);
            });
        });

        // Create control panel
        const controlPanel = d3.select("body")
          .append("div")
          .attr("class", "control-panel");
          
        // Add legend
        const legend = d3.select("body")
          .append("div")
          .attr("class", "legend");
          
        legend.append("div")
          .text("Networks")
          .style("font-weight", "bold")
          .style("margin-bottom", "8px");
          
        Object.keys(networks).forEach(key => {
          const legendItem = legend.append("div")
            .attr("class", "legend-item");
            
          legendItem.append("div")
            .attr("class", "legend-color")
            .style("background-color", networks[key].style.color);
            
          legendItem.append("div")
            .text(key);
        });

        // Button for showing/hiding names
        let namesVisible = true;
        const namesControl = controlPanel
          .append("div")
          .attr("class", "control-button");
          
        namesControl.append("div")
          .attr("class", "button-circle")
          .style("background-color", "#000000")
          .html('<svg width="24" height="24" viewBox="0 0 24 24" fill="white"><path d="M12 2C6.48 2 2 6.48 2 12s4.48 10 10 10 10-4.48 10-10S17.52 2 12 2zm0 15c-.55 0-1-.45-1-1v-4c0-.55.45-1 1-1s1 .45 1 1v4c0 .55-.45 1-1 1zm1-8h-2V7h2v2z"/></svg>')
          .on("click", function() {
            namesVisible = !namesVisible;
            if (namesVisible) {
              d3.selectAll(".network-name").style("display", "block");
              d3.select(this).style("background-color", "#000000");
            } else {
              d3.selectAll(".network-name").style("display", "none");
              d3.select(this).style("background-color", "#555555");
            }
          });
          
        namesControl.append("div")
          .attr("class", "button-label")
          .text("Names");

        // Button for toggling nested charts
        const nestedControl = controlPanel
          .append("div")
          .attr("class", "control-button");
          
        nestedControl.append("div")
          .attr("class", "button-circle")
          .style("background-color", "#555555")
          .html('<svg width="24" height="24" viewBox="0 0 24 24" fill="white"><path d="M12 2C6.48 2 2 6.48 2 12s4.48 10 10 10 10-4.48 10-10S17.52 2 12 2zm0 3c1.66 0 3 1.34 3 3s-1.34 3-3 3-3-1.34-3-3 1.34-3 3-3zm0 14.2c-2.5 0-4.71-1.28-6-3.22.03-1.99 4-3.08 6-3.08 1.99 0 5.97 1.09 6 3.08-1.29 1.94-3.5 3.22-6 3.22z"/></svg>')
          .on("click", function() {
            nestedChartsVisible = !nestedChartsVisible;
            
            if (nestedChartsVisible) {
              d3.select(this).style("background-color", "#000000");
            } else {
              d3.select(this).style("background-color", "#555555");
            }
            
            // Update all charts to reflect the new visibility setting
            Object.keys(networks).forEach((networkId) => {
              const svgGroup = svgGroups[networkId];
              const data = networks[networkId].recognitions.map((s) => ({
                label: `Recognition in ${s.id}`,
                value: s.value,
                nestedRecognition: s.id,
              }));
              const arcs = recognitionChart(data);
              updateNestedCharts(svgGroup, arcs);
            });
          });
          
        nestedControl.append("div")
          .attr("class", "button-label")
          .text("Nested");

        // Button for creating new networks/nodes
        const addControl = controlPanel
          .append("div")
          .attr("class", "control-button");
          
        addControl.append("div")
          .attr("class", "button-circle")
          .style("background-color", "#000000")
          .html('<svg width="24" height="24" viewBox="0 0 24 24" fill="white"><path d="M19 13h-6v6h-2v-6H5v-2h6V5h2v6h6v2z"/></svg>')
          .on("click", function() {
            const newNetworkId = "Network" + (Object.keys(networks).length + 1);
            networks[newNetworkId] = {
              id: newNetworkId,
              recognitions: [],
              style: {
                color: "#" + Math.floor(Math.random()*16777215).toString(16),
              },
              surplus: [],
              svgGroup: undefined,
            };
            
            // Add some recognitions to the new network
            Object.keys(networks).forEach(existingNetwork => {
              if (existingNetwork !== newNetworkId) {
                networks[newNetworkId].recognitions.push({
                  id: existingNetwork,
                  value: 20,
                  denomination: newNetworkId
                });
              }
            });
            
            updateGraph(link, node);
            
            // Update the legend
            legend.selectAll("*").remove();
            legend.append("div")
              .text("Networks")
              .style("font-weight", "bold")
              .style("margin-bottom", "8px");
              
            Object.keys(networks).forEach(key => {
              const legendItem = legend.append("div")
                .attr("class", "legend-item");
                
              legendItem.append("div")
                .attr("class", "legend-color")
                .style("background-color", networks[key].style.color);
                
              legendItem.append("div")
                .text(key);
            });
          });
          
        addControl.append("div")
          .attr("class", "button-label")
          .text("Add Network");

        // Add a reset zoom button
        const resetControl = controlPanel
          .append("div")
          .attr("class", "control-button");
          
        resetControl.append("div")
          .attr("class", "button-circle")
          .style("background-color", "#000000")
          .html('<svg width="24" height="24" viewBox="0 0 24 24" fill="white"><path d="M12 5V1L7 6l5 5V7c3.31 0 6 2.69 6 6s-2.69 6-6 6-6-2.69-6-6H4c0 4.42 3.58 8 8 8s8-3.58 8-8-3.58-8-8-8z"/></svg>')
          .on("click", function() {
            svg.transition().duration(750).call(
              zoom.transform,
              d3.zoomIdentity
            );
          });
          
        resetControl.append("div")
          .attr("class", "button-label")
          .text("Reset Zoom");

        const simulation = d3
          .forceSimulation(graphData.nodes)
          .force(
            "link",
            d3
              .forceLink(graphData.links)
              .id((d) => d.id)
              .distance((d) => (d.type === "surplus" ? 50 : 250))
          )
          .force("charge", d3.forceManyBody().strength(75))
          .force("center", d3.forceCenter(width / 2, height / 2))
          .force("collision", d3.forceCollide().radius(100));

        simulation.nodes(graphData.nodes).on("tick", ticked);

        simulation.force("link").links(graphData.links);

        function ticked() {
          link.attr("d", (d) => generateLinkPath(d.source, d.target));
          node
            .selectAll("svg")
            .attr("x", (d) => d.x - 100)
            .attr("y", (d) => d.y - 100);
        }
      }

      createNetworkGraph();
    </script>
  </body>
</html>
