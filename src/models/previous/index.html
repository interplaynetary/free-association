<html>
  <body>
    <h1>Free Association</h1>

    <form id="sign">
      <input id="alias" placeholder="username" autocomplete="username">
      <input id="pass" type="password" placeholder="passphrase" autocomplete="current-password">
      <input id="enter" type="button" value="enter">
    </form>

    <ul></ul>

    <form id="said">
        <input id="say">
        <input id="speak" type="submit" value="speak">
    </form>

    <script src="https://cdn.jsdelivr.net/npm/gun/examples/jquery.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/gun/gun.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/gun/sea.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/gun/lib/unset.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/gun/lib/webrtc.js"></script>
   <!-- <script src="https://cdn.jsdelivr.net/npm/joydb/joy.min.js"></script>  Joy for our UI 
    <script src="https://cdn.jsdelivr.net/npm/gun/lib/radix.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/gun/lib/radisk.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/gun/lib/store.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/gun/lib/rindexed.js"></script> -->
    <script>
        var gun = Gun(['http://127.0.0.1:5500/gun', /*'https://gun-manhattan.herokuapp.com/gun'*/]);

        var user = gun.user();
        user.recall({sessionStorage: true}) // remember the user, stay logged in

        $('#enter').on('click', function(e){
            e.preventDefault();
            user.auth($('#alias').val(), $('#pass').val(), function(err) {
                if (err) {
                    // If sign-in fails, attempt to sign up
                    user.create($('#alias').val(), $('#pass').val());
                }
            });
        });

        // 1) When the user adds an item, save and sync it with GUN.
        $('#said').on('submit', function(e){
            e.preventDefault();
            if(!user.is){ return }
            user.get('said').set($('#say').val());
            $('#say').val("");
        });
        // 2) Update the UI.
        function UI(say, id){
            var li = $('#' + id).get(0) || $('<li>').attr('id', id).appendTo('ul');
            $(li).text(say);
            };

        // 3) Change the UI upon logging out or into the app.
        gun.on('auth', function(){
            $('#sign').hide();
            user.get('said').map().once(UI);
        });

        
/*
Data can be in graphs that link across different spaces. So don't assume data is only in one space! For instance, user data can point to public data which can be edited by anyone, just not the link itself. Likewise, public data could link to frozen or user data, but anyone could edit the link itself. One very powerful combination is frozen links to user data, nobody can edit the link but the data itself can be updated by the owner.

gun.get('#users').map().get('country').on(data => console.log(data))
Pretend that #users is a frozen list where each item links to a user profile. Rather than a user saving {name: "Alice", country: "USA"} to their profile, they could instead link to the public wiki about their country. Now our query will get the the country data of each user, like {name: "United States of America", code: "USA", population: 300,000,000} as it is updated in realtime.
*/

//   gun = Gun(['http://localhost:8765/gun', 'https://gun-manhattan.herokuapp.com/gun']);
//   copy = gun.get('test').get('paste');
//   paste.oninput = () => { copy.put(paste.value) };
//   copy.on((data) => { paste.value = data });

/*
From Guide:
How? 
First we setup a small amount of HTML to make a full size text area for users to type into. Then we load GUN and connect to our local relay or some other peers. All peers, even your browser, help other peers find data and each other. This keeps things decentralized.

Next we ask gun to get some data. This could be anything, like "Mark's age", or the paste record on the test table. We can keep chaining these queries together to traverse any graph of data.

copy is a chain reference to the data, it is not the value of the data yet.

Before we can read any data, we first must write to it on the reference. So we add an oninput callback listener to the HTML paste id. This fires with events any time the user inputs or changes a value. Now all we have to do is call put to save data on that chain reference. GUN will now synchronize it to other peers online.

Finally, we want to listen to realtime updates on the chain reference. Just like how we added a listener to the HTML, we can also add a listener to GUN. It gets called with data which is the raw actual value we want, and we then update the paste textarea with that value.

Whenever we refresh the page, .on( will also get and merge the latest cached data.

Note: If no data is found on the key ('alice', etc.) when we .get it, gun will implicitly create and update it upon a .put. This is useful and convenient for most but not all apps.

*/

// ideally our node.id is our node's Souls id?


const alice = saveNode('alice', 'alice')
const bob = saveNode('bob', 'bob')
const charlie = saveNode('charlie', 'charlie')
const subverse = saveNode('subverse', 'subverse', alice)
const space = saveNode('space', 'space', alice)
const universe = saveNode('universe', 'universe')
alice.on((data) => {
    console.log('alice!', data)
})

bob.on((data) => {
    console.log('bob!', data)
})

charlie.on((data) => {
    console.log('charlie!', data)
})

subverse.on((data) => {
    console.log('subverse!', data)
})

space.on((data) => {
    console.log('space!', data)
})

universe.on((data) => {
    console.log('universe!', data)
})

setParent(subverse, bob)
// these are mirrors of each other.
setParent(charlie, bob)

setPoints(charlie, 100)

setPoints(subverse, 50)


getPoints(subverse)

addType(subverse, universe)

console.log(subverse.get('types').once((data) => {
    console.log('subverse type!', data)
}))

console.log(universe.get('instances').once((data) => {
    console.log('universe instance!', data)
}))

removeType(subverse, universe)

console.log(subverse.get('types').once((data) => {
    console.log('subverse type!', data)
}));

(async () => {
    console.log('total child points!', await getTotalChildPoints(bob))
})()

// All users are nodes, not all nodes are users. All users are types, which can be referenced by other nodes.

function saveNode(name, parent = null, children = [], types = [], manualFulfillment = 0) {
    const node = user.get(name)
    node.get('name').put(name)
    if(parent) {
        node.get('parent').put(parent)
    }
    if(children.length > 0) {
        addChildren(node, children)
    }
    if(types.length > 0) {
        addTypes(node, types)
    }
    if(parent && manualFulfillment) {
        setManualFulfillment(node, manualFulfillment)
    }
    return node
}

function getName(node) {
    return node.get('name')
}

function setName(node, name) {
    node.get('name').put(name)
}

function getParent(node) {
    return node.get('parent')
}

function getChildren(node) {
    return node.get('children')
}

// setParent and addChild are mirrors of each other.
function setParent(child, parent) {
    child.get('parent').put(parent)
    parent.get('children').set(child)
}

function addChild(parent, child) {
    parent.get('children').set(child)
    child.get('parent').put(parent)
}

function addChildren(parent, children = []) {
    children.forEach(child => {
        addChild(parent, child)
    })
}

// I am uncertain whether unset is working!
function removeChild(parent, child) {
    parent.get('children').unset(child)
    child.get('parent').unset(parent)
}

function getPoints(node) {
    return node.get('points')
}

function setPoints(node, points) {
    node.get('points').put(points)
}

function getTypes(node) {
    return node.get('types')
}

function getInstances(type) {
    return type.get('instances')
}

function addType(instance, type) {
    instance.get('types').set(type)
    type.get('instances').set(instance)
}

function addTypes(instance, types = []) {
    types.forEach(type => {
        addType(instance, type)
    })
}

// I am uncertain whether unset is working!
function removeType(instance, type) {
    instance.get('types').unset(type)
    type.get('instances').unset(instance)
}

// I am uncertain whether unset is working!
// These will be used to shift types/roles based on surplus!
function shiftType(instance, type, newInstance) {
    removeType(instance, type)
    addType(newInstance, type)
}

// I am uncertain whether unset is working!
function shiftTypes(instance, types, newInstance) {
    types.forEach(type => {
        shiftType(instance, type, newInstance)
    })
}

// I am uncertain whether unset is working!
function removeInstance(type, instance) {
    type.get('instances').unset(instance)
    instance.get('types').unset(type)
}

function getManualFulfillment(node) {
    return node.get('manualFulfillment')
}

function setManualFulfillment(node, manualFulfillment = 0) {
    if (!hasDirectContributorChild(node)) {
        throw new Error(
          'Can only manually set fulfillment for parents of contributors'
        );
      }
      if (manualFulfillment < 0 || manualFulfillment > 1) {
        throw new Error('Fulfillment must be between 0 and 1');
      }
    node.get('manualFulfillment').put(manualFulfillment)
}

/*
From Guide:
It is now easy to iterate through our list of people.

people.map().once(function(person){
  console.log("The person is", person);
});

Note: If .map is given no callback, it simply iterates over each item in the list "as is" - thus acting like a for each loop in javascript. 
Also, everything is continuously evaluating in GUN, including .map, so it will get called when new items are added as well as when an item is updated. 
It does not iterate through the whole list again every time, just the changes. This is great for realtime applications.
*/

// FROM HERE ON OUT: gun.load() load the entire state as a synchronous object. that we just run calculations on.

async function getTotalChildPoints(node) {
    let totalPoints = 0
    await node.get('children').once().map().once(function(child){
        console.log('child XXX!', child.name, child.points)
        if(child.points) {
            totalPoints += child.points
        }
    }, {wait: 5})
    console.log('total points!', totalPoints)
    return totalPoints
}

function isContributor(node) {
    // This is a standin for simply checking if the node is a USER.
    let isContributor = true
        node.get('types').map().once(function(type){
        type.get('parent').once(function(parent){
        if(parent) {
            isContributor = false
        }
        });
    });
    return isContributor
}

function getContributorChildren(node) {
    const contributorChildren = []
    node.get('children').map().once(function(child){
        if (isContributor(child)) {
            contributorChildren.push(child)
        }
    });
    return contributorChildren
}

// How could it possibly be a Contributor if it is a child!
function getNonContributorChildren(node) {
    const nonContributorChildren = []
    node.get('children').map().once(function(child){
        if (!isContributor(child)) {
            nonContributorChildren.push(child)
        }
    });
    return nonContributorChildren
}

// how do we implement this using Gun? We need to get all types within a given Users-space, and cant assume to know it!
function getAllTypes() {
    const allTypes = []
    user.map().once(function(type){
        if(type.get('instances').size > 0) {
            allTypes.push(type)
        }
    });
    return allTypes
}

function getAllContributors() {
    const contributors = []
    getAllTypes().map().once(function(type){
        if (isContributor(type)) {
            contributors.push(type)
        }
    });
    return contributors
}


/*
From Guide:
After you save some data in an unordered list, you may need to remove it.
        let gun = new Gun();
        let machines = gun.get('machines');
        let machine = gun.get('machine/tesseract');
        machine.put({faces: 24, cells: 8, edges: 32});
        // let's add machine to the list of machines;
        machines.set(machine);
        // now let's remove machine from the list of machines
        machines.unset(machine);
*/

/*
From Guide:
Finally, let's read some data out. Starting with getting a key/value, then navigating into a document, then mapping over a table, then traversing into one of the columns and printing out all the values!

gun.get('alice').get('spouse').get('employer').get('employees').map().get('name').once(function(data, key){
  console.log("The employee's", key, data);
});
*/

/*
Note: We can have 1-1, 1-N, N-N relationships. By default every relationship is a "directed" graph (it only goes in one direction), so if you want bi-directional relationships you must explicitly save the data as being so (like with Dave and his kid, Carl). 

If you want to have meta information about the relationship, simply create an "edge" node that both properties point to instead. Many graph databases do this by default, but because not all data structures require it, gun leaves it to you to specify.

// Perhaps we should have mutual-recognition and roles be edge relationship between nodes! That is derived?
*/




// I wonder if we should even have a live-memory version, or if we should just use Gun for everything.
// and write our functions to work over the live data.






// FUNCTIONS THAT OPERATE OVER THE LIVE DATA

/*
From Guide:
To implement our functional backwards traversal algorithms we can use gun.back(amount)
gun.back(amount) #
Move up to the parent context on the chain.

Every time a new chain is created, a reference to the old context is kept to go back to.

Amount 
The number of times you want to go back up the chain. -1 or Infinity will take you to the root.

Examples 
Moving to a parent context

gun.get('users')
  // now change the context to alice
  .get('alice')
  .put(data)
  // go back up the chain once, to 'users'
  .back().map(...)
Another example

gun.get('player').get('game').get('score').back(1)
// is the same as...
gun.get('player').get('game')
Chain context 
The context will always be different, returning you to the

gun.get('key').get('property')
    // is not the same as
gun.get('key').get('property').back()

*/


  function getWeight(node) {
    if (!getParent(node)) return 1;
    return getTotalChildPoints(getParent(node)) === 0
      ? 0
      : (getPoints(node) / getTotalChildPoints(getParent(node))) * getWeight(getParent(node));
  }

  // shareOfParent() -> how many points this node has, as fraction of totalChildPoints.
  // used to distribute contribution/fulfillment upward or across siblings.
  
  function shareOfParent(node) {
      if (!getParent(node)) return 1;
      return getTotalChildPoints(getParent(node)) === 0
        ? 0
        : getPoints(node) / getTotalChildPoints(getParent(node));
    };

    function hasDirectContributorChild(node) {
        const result = false
        getChildren(node).map().once(function(child){
            if (isContributor(child)) {
                result = true
            }
        });
        return result
    };
    
  function hasNonContributorChild(node) {
        const result = false
        getChildren(node).map().once(function(child){
            if (!isContributor(child)) {
                result = true
            }
        });
        return result
  };




  function contributorChildrenWeight (node) {
      const contributorPoints = getContributorChildren(node)
        .reduce((sum, child) => sum + child.get('points'), 0);

      return contributorPoints / getTotalChildPoints(node);
  };

  function contributorChildrenFulfillment(node) {
      const contributorChildren = getContributorChildren(node)

      return contributorChildren.reduce(
        (sum, child) => sum + fulfilled(child) * shareOfParent(child),
        0
      );
    };

    function nonContributorChildrenFulfillment(node) {
      const nonContributorChildren = getNonContributorChildren(node)

      return nonContributorChildren.reduce(
        (sum, child) => sum + fulfilled(child) * shareOfParent(child),
        0
      );
    };

    
  // The core method: fulfilled():
  // 1. Leaf nodes with isContributor == true → full 1.0 fulfillment
  // 2. Leaf nodes with isContributor == false → 0
  // 3. If _manualFulfillment is set and node has both contributor and non-contributor children:
  //    merges the manual fulfillment for contributor children with the calculated fulfillment for non-contributor children using a weighted approach.
  // 4. Otherwise falls back to summing child fulfillments * shareOfParent().

/*

  function fulfilled(node) {
      // For leaf nodes (no children)
      if (getChildren(node).size === 0) {
        return isContributor(node) ? 1 : 0;
      }

      // If fulfillment was manually set and node has contributor children
      if (
        getManualFulfillment(node) !== null &&
        hasDirectContributorChild(node)
      ) {
        // If we only have contributor children, return manual fulfillment
        if (!hasNonContributorChild(node)) {
          return getManualFulfillment(node);
        }

        // For hybrid case: combine manual fulfillment for contributor children
        // with calculated fulfillment for non-contributor children
        const contributorChildrenWeight =
          contributorChildrenWeight(node);
        const nonContributorFulfillment =
          nonContributorChildrenFulfillment(node);

        return (
          getManualFulfillment(node) * contributorChildrenWeight +
          nonContributorFulfillment * (1 - contributorChildrenWeight)
        );
      }

      // Default case: calculate from all children
      return getChildren(node).reduce(
        (sum, child) => sum + fulfilled(child) * shareOfParent(child),
        0
      );
    };

  function desire(node) {
        return 1 - fulfilled(node);
    };

  function fulfillmentWeight(node) {
    return fulfilled(node) * getWeight(node);
  }

  function shareOfGeneralFulfillment(rootNode, node) {
    return getInstances(rootNode, node).map().once(function(instance){
    // we have a parameter mismatch here
    .reduce((sum, instance) => {
        // Convert types Set to Array before filtering
        let contributorTypesCount = 0
        getTypes(instance).map().once(function(type){
            if(isContributor(type)) {
                contributorTypesCount++
            }
        });

        const fulfillmentWeight = fulfillmentWeight(instance);

        const weightShare =
            contributorTypesCount > 0
                ? fulfillmentWeight / contributorTypesCount
                : fulfillmentWeight;

        return sum + weightShare;
    }, 0);
    }
  }

  function shareOfGeneralFulfillmentDistribution(node) {
    return getAllContributors().map().once(function(contributor){
        return {
        contributor,
        value: shareOfGeneralFulfillment(node, contributor),
    }}).filter(entry => entry.value > 0);
  }

  function mutualFulfillment(node, otherNode) {
    const recognitionFromHere = shareOfGeneralFulfillment(node, otherNode);
    const recognitionFromThere = shareOfGeneralFulfillment(otherNode, node);
    return Math.min(recognitionFromHere, recognitionFromThere);
  }

  function mutualFulfillmentDistribution(node) {
    const contributors = getAllContributors()

    const rawDistribution = contributors
        .map(contributor => ({
            contributor,
            value: mutualFulfillment(node, contributor),
        }))
        .filter(entry => entry.value > 0);

    const total = rawDistribution.reduce((sum, entry) => sum + entry.value, 0);

    return rawDistribution.map(entry => [
        entry.contributor,
        total > 0 ? entry.value / total : 0,
    ]);
  }
*/
    </script>
  </body>
</html>