/// <reference types="@sveltejs/kit" />
/// <reference no-default-lib="true"/>
/// <reference lib="esnext" />
/// <reference lib="webworker" />

import { precacheAndRoute, cleanupOutdatedCaches } from 'workbox-precaching';
import {
	loadSubscriptionConfig,
	interpolateTemplate,
	buildNotificationUrl,
	shouldProcessData,
	processDataForNotification,
	validateSubscription,
	type ServiceWorkerSubscriptionConfig
} from './sw-utils';

const sw = self as unknown as ServiceWorkerGlobalScope & typeof globalThis;

// Precache all the assets generated by your build process
precacheAndRoute(sw.__WB_MANIFEST);
cleanupOutdatedCaches();

// Gun P2P state
let gun: any;
let user: any;
let gunReady = false;
let subscriptions: ServiceWorkerSubscriptionConfig[] = [];
let activeListeners: Array<() => void> = []; // For cleanup

// Message types
interface GunMessage {
	type: 'INIT_GUN' | 'SETUP_SUBSCRIPTIONS' | 'GUN_AUTH' | 'SEND_MESSAGE' | 'SKIP_WAITING';
	config?: ServiceWorkerSubscriptionConfig[];
	credentials?: { alias: string; password: string };
	message?: { text: string; chatId?: string };
}

// Initialize Gun
async function initGun(): Promise<boolean> {
	try {
		console.log('[SW] Initializing Gun...');
		const [GUN] = await Promise.all([import('gun'), import('gun/sea')]);

		gun = GUN.default(['https://gun-manhattan.herokuapp.com/gun', 'https://peer.wallie.io/gun']);
		user = gun.user();
		gunReady = true;

		console.log('[SW] Gun initialized');
		return true;
	} catch (error) {
		console.error('[SW] Gun initialization failed:', error);
		return false;
	}
}

// Setup subscriptions with validation
async function setupSubscriptions(config?: ServiceWorkerSubscriptionConfig[]): Promise<void> {
	if (!gunReady) {
		console.warn('[SW] Gun not ready, deferring subscription setup');
		return;
	}

	// Clear existing listeners
	activeListeners.forEach((cleanup) => cleanup());
	activeListeners = [];

	// Load and validate config
	const rawSubscriptions = config || (await loadSubscriptionConfig());
	subscriptions = rawSubscriptions.filter(validateSubscription);

	if (subscriptions.length !== rawSubscriptions.length) {
		console.warn(
			`[SW] Filtered out ${rawSubscriptions.length - subscriptions.length} invalid subscriptions`
		);
	}

	console.log(`[SW] Setting up ${subscriptions.length} subscriptions`);

	// Setup each subscription
	subscriptions.forEach(setupSubscription);
}

// Unified subscription setup
function setupSubscription(subscription: ServiceWorkerSubscriptionConfig): void {
	const { id, path, scope } = subscription;

	try {
		if (path === '*' || path === '') {
			// For wildcard, listen to multiple common paths
			const commonPaths = ['chat', 'rooms', 'capacities', 'players'];
			commonPaths.forEach((commonPath) => {
				const cleanup = createPathListener(subscription, commonPath, scope);
				if (cleanup) activeListeners.push(cleanup);
			});
			console.log(`[SW] Setup wildcard subscription for ${id}`);
		} else {
			// Specific path subscription
			const cleanup = createPathListener(subscription, path, scope);
			if (cleanup) activeListeners.push(cleanup);
			console.log(`[SW] Setup subscription for ${id} (${scope}:${path})`);
		}
	} catch (error) {
		console.error(`[SW] Failed to setup subscription ${id}:`, error);
	}
}

// Create path listener with cleanup function
function createPathListener(
	subscription: ServiceWorkerSubscriptionConfig,
	path: string,
	scope: 'gun' | 'user'
): (() => void) | null {
	try {
		const gunRef = scope === 'user' ? user.get(path) : gun.get(path);

		// Create handler
		const handler = (data: any, key: string) => {
			if (shouldProcessData(data, key, subscription)) {
				handleDataChange(data, key, subscription).catch((error) =>
					console.error(`[SW] Error handling data change:`, error)
				);
			}
		};

		// Set up listener
		gunRef.map().on(handler);

		// Return cleanup function
		return () => {
			try {
				gunRef.map().off(handler);
			} catch (error) {
				console.warn(`[SW] Error cleaning up listener:`, error);
			}
		};
	} catch (error) {
		console.error(`[SW] Error creating listener for ${path}:`, error);
		return null;
	}
}

// Handle data changes and show notifications
async function handleDataChange(
	data: any,
	key: string,
	subscription: ServiceWorkerSubscriptionConfig
): Promise<void> {
	try {
		const { notification, processor } = subscription;

		// Process data generically
		let processedData = processDataForNotification(data, key);

		// Apply custom processor if specified
		if (processor && processors[processor]) {
			try {
				processedData = await processors[processor](processedData, key);
			} catch (error) {
				console.warn(`[SW] Custom processor ${processor} failed:`, error);
			}
		}

		// Build notification options
		const notificationOptions: NotificationOptions & {
			vibrate?: number[];
			actions?: Array<{ action: string; title: string; icon?: string }>;
		} = {
			body: interpolateTemplate(notification.body, processedData),
			icon: notification.icon || '/favicon.png',
			badge: notification.badge || '/favicon.png',
			tag: notification.tag
				? interpolateTemplate(notification.tag, processedData)
				: `${subscription.id}-${key}`,
			requireInteraction: notification.requireInteraction || false,
			data: {
				subscriptionId: subscription.id,
				subscription,
				key,
				processedData,
				timestamp: Date.now()
			}
		};

		// Add optional properties
		if (notification.vibrate) notificationOptions.vibrate = notification.vibrate;

		// Add conditional actions
		if (notification.actions) {
			notificationOptions.actions = notification.actions.filter((action) => {
				// Check if action should be shown based on condition
				if (action.condition) {
					try {
						// Simple condition evaluation - check if field exists
						return processedData[action.condition] !== undefined;
					} catch {
						return true; // Default to showing if condition evaluation fails
					}
				}
				return true;
			});
		}

		await sw.registration.showNotification(
			interpolateTemplate(notification.title, processedData),
			notificationOptions
		);

		console.log(`[SW] Notification sent for ${subscription.id}`);
	} catch (error) {
		console.error(`[SW] Notification error for ${subscription.id}:`, error);
	}
}

// Custom processors for special data handling (completely optional)
const processors: Record<string, (data: any, key: string) => Promise<any>> = {
	// Example: decrypt encrypted messages
	async decrypt(data: any, key: string) {
		try {
			const SEA = await import('gun/sea');
			if (data.what && typeof data.what === 'string') {
				const decrypted = await SEA.default.decrypt(data.what, '#foo');
				if (decrypted) {
					data.decryptedMessage = decrypted;
					data._preview = decrypted;
				}
			}
		} catch (error) {
			console.warn('[SW] Decryption failed:', error);
		}
		return data;
	},

	// Example: fetch user info
	async enrichUser(data: any, key: string) {
		try {
			if (data.user && gun) {
				const userAlias = await gun.get(`~${data.user}`).get('alias');
				if (userAlias) {
					data.userName = userAlias;
					data._preview = `${userAlias}: ${data._preview}`;
				}
			}
		} catch (error) {
			console.warn('[SW] User enrichment failed:', error);
		}
		return data;
	}
};

// Send message (generic function)
async function sendMessage(messageText: string, chatId = 'chat'): Promise<void> {
	try {
		const SEA = await import('gun/sea');
		const secret = await SEA.default.encrypt(messageText, '#foo');
		const message = user.get('all').set({ what: secret });

		gun.get(chatId).get(new Date().toISOString()).put(message);
	} catch (error) {
		console.error('[SW] Send message error:', error);
	}
}

// Message handler
sw.addEventListener('message', async (event) => {
	const message: GunMessage = event.data;

	const handlers = {
		INIT_GUN: () => initGun(),
		SETUP_SUBSCRIPTIONS: () => setupSubscriptions(message.config),
		GUN_AUTH: () =>
			message.credentials && user.auth(message.credentials.alias, message.credentials.password),
		SEND_MESSAGE: () =>
			message.message && sendMessage(message.message.text, message.message.chatId),
		SKIP_WAITING: () => sw.skipWaiting()
	};

	const handler = handlers[message.type];
	if (handler) {
		try {
			await handler();
		} catch (error) {
			console.error(`[SW] Handler error for ${message.type}:`, error);
		}
	}
});

// Notification click handler
sw.addEventListener('notificationclick', (event) => {
	event.notification.close();

	const action = event.action;
	const data = event.notification.data;
	const subscription = data?.subscription;

	if (!subscription) {
		// Fallback to home page
		event.waitUntil(sw.clients.openWindow('/'));
		return;
	}

	const url = buildNotificationUrl(subscription, action || 'default', data.processedData);

	event.waitUntil(
		sw.clients
			.matchAll({ type: 'window' })
			.then((clients) => (clients.length > 0 ? clients[0].focus() : sw.clients.openWindow(url)))
	);
});

// Notification close handler
sw.addEventListener('notificationclose', (event) => {
	console.log(`[SW] Notification closed: ${event.notification.tag}`);
});

// Activation handler
sw.addEventListener('activate', (event) => {
	event.waitUntil(
		sw.clients.claim().then(async () => {
			console.log('[SW] Activated');
			await initGun();
		})
	);
});

// Keep Gun connection alive
setInterval(() => {
	if (gunReady && gun) {
		gun.get('heartbeat').put({ timestamp: Date.now() });
	}
}, 30000);
