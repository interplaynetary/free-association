// 1. Install and configure @vite-pwa/sveltekit
// npm install -D @vite-pwa/sveltekit

// vite.config.js
import { sveltekit } from '@sveltejs/kit/vite'
import { SvelteKitPWA } from '@vite-pwa/sveltekit'

export default {
  plugins: [
    sveltekit(),
    SvelteKitPWA({
      strategies: 'injectManifest',
      srcDir: 'src',
      filename: 'service-worker.js',
      scope: '/',
      base: '/',
      selfDestroying: false,
      manifest: {
        name: 'My P2P App',
        short_name: 'P2P App',
        description: 'A P2P Progressive Web App',
        theme_color: '#ffffff',
        background_color: '#ffffff',
        display: 'standalone',
        scope: '/',
        start_url: '/',
        icons: [
          {
            src: 'icon-192.png',
            sizes: '192x192',
            type: 'image/png'
          },
          {
            src: 'icon-512.png',
            sizes: '512x512',
            type: 'image/png'
          }
        ]
      },
      workbox: {
        globPatterns: ['client/**/*.{js,css,ico,png,svg,webp,woff,woff2}']
      },
      devOptions: {
        enabled: true,
        type: 'module'
      }
    })
  ]
}

// 2. Configure SvelteKit to disable automatic service worker registration
// svelte.config.js
import adapter from '@sveltejs/adapter-auto'

/** @type {import('@sveltejs/kit').Config} */
const config = {
  kit: {
    adapter: adapter(),
    serviceWorker: {
      register: false // Disable automatic registration
    },
    files: {
      serviceWorker: 'src/service-worker.js'
    }
  }
}

export default config

// 3. Create your custom service worker with notification support
// src/service-worker.js
import { precacheAndRoute, cleanupOutdatedCaches } from 'workbox-precaching'

declare let self: ServiceWorkerGlobalScope

// Precache all the assets generated by your build process
precacheAndRoute(self.__WB_MANIFEST)

// Clean up old caches
cleanupOutdatedCaches()

// Handle messages from main thread for notifications
self.addEventListener('message', (event) => {
  if (event.data.type === 'SHOW_NOTIFICATION') {
    const { title, options } = event.data.payload
    
    self.registration.showNotification(title, {
      body: options.body || '',
      icon: options.icon || '/icon-192.png',
      badge: options.badge || '/icon-192.png',
      tag: options.tag || 'default',
      data: options.data || {},
      actions: options.actions || [],
      requireInteraction: options.requireInteraction || false,
      silent: options.silent || false,
      vibrate: options.vibrate || [200, 100, 200],
      timestamp: Date.now()
    })
  }
})

// Handle notification clicks
self.addEventListener('notificationclick', (event) => {
  event.notification.close()
  
  const action = event.action
  const data = event.notification.data
  
  if (action === 'reply') {
    event.waitUntil(
      clients.openWindow(`/chat/${data.peerId}?action=reply`)
    )
  } else if (action === 'view') {
    event.waitUntil(
      clients.openWindow(`/chat/${data.peerId}?message=${data.messageId}`)
    )
  } else {
    // Default click - focus existing window or open new one
    event.waitUntil(
      clients.matchAll({ type: 'window' }).then((clientList) => {
        if (clientList.length > 0) {
          return clientList[0].focus()
        }
        return clients.openWindow('/')
      })
    )
  }
})

// Handle notification close
self.addEventListener('notificationclose', (event) => {
  console.log('Notification closed:', event.notification.tag)
})

// Skip waiting to activate immediately
self.addEventListener('message', (event) => {
  if (event.data && event.data.type === 'SKIP_WAITING') {
    self.skipWaiting()
  }
})

// 4. Add PWA manifest and service worker registration to your main layout
// src/routes/+layout.svelte
<script>
  import { onMount } from 'svelte'
  import { browser } from '$app/environment'
  import { pwaInfo } from 'virtual:pwa-info'
  
  let notificationManager
  
  onMount(async () => {
    if (browser && pwaInfo) {
      // Register service worker and request notification permission
      const { registerSW } = await import('virtual:pwa-register')
      
      // Request notification permission
      if ('Notification' in window && Notification.permission === 'default') {
        await Notification.requestPermission()
      }
      
      registerSW({
        immediate: true,
        onRegistered(registration) {
          console.log('SW Registered:', registration)
          
          // Initialize notification manager
          notificationManager = new P2PNotificationManager(registration)
          
          // Make it globally available for your P2P code
          if (typeof window !== 'undefined') {
            window.notificationManager = notificationManager
          }
        },
        onRegisterError(error) {
          console.log('SW registration error', error)
        }
      })
    }
  })
  
  $: webManifestLink = pwaInfo ? pwaInfo.webManifest.linkTag : ''
</script>

<svelte:head>
  {@html webManifestLink}
</svelte:head>

<main>
  <slot />
</main>

// 5. Create notification manager for your P2P app
// src/lib/notifications.js
export class P2PNotificationManager {
  constructor(registration = null) {
    this.registration = registration
    this.activeNotifications = new Map()
  }
  
  async showNotification(title, options = {}) {
    // Check if notifications are supported and permitted
    if (!('Notification' in window)) {
      console.warn('Notifications not supported')
      return
    }
    
    if (Notification.permission !== 'granted') {
      console.warn('Notifications not permitted')
      return
    }
    
    // Send message to service worker
    if ('serviceWorker' in navigator && navigator.serviceWorker.controller) {
      navigator.serviceWorker.controller.postMessage({
        type: 'SHOW_NOTIFICATION',
        payload: { title, options }
      })
      
      // Track notification
      if (options.tag) {
        this.activeNotifications.set(options.tag, { title, options })
      }
    }
  }
  
  // P2P specific notification methods
  onPeerConnected(peerId, peerName = null) {
    this.showNotification(`Peer Connected`, {
      body: `${peerName || peerId} joined the session`,
      tag: `peer-connected-${peerId}`,
      icon: '/icon-192.png',
      data: { type: 'peer-connected', peerId }
    })
  }
  
  onPeerMessage(message, peerId, peerName = null) {
    this.showNotification(`New Message`, {
      body: `${peerName || peerId}: ${message.text}`,
      tag: `message-${peerId}`,
      icon: '/icon-192.png',
      actions: [
        { action: 'reply', title: 'Reply' },
        { action: 'view', title: 'View Chat' }
      ],
      data: { 
        type: 'message', 
        peerId, 
        messageId: message.id,
        peerName 
      }
    })
  }
  
  onFileReceived(filename, peerId, peerName = null) {
    this.showNotification(`File Received`, {
      body: `${peerName || peerId} sent: ${filename}`,
      tag: `file-${peerId}-${Date.now()}`,
      icon: '/icon-192.png',
      actions: [
        { action: 'download', title: 'Download' },
        { action: 'view', title: 'View Files' }
      ],
      data: { 
        type: 'file', 
        peerId, 
        filename,
        peerName 
      }
    })
  }
  
  onConnectionLost(peerId, peerName = null) {
    this.showNotification(`Connection Lost`, {
      body: `Lost connection to ${peerName || peerId}`,
      tag: `connection-lost-${peerId}`,
      icon: '/icon-192.png',
      data: { type: 'connection-lost', peerId }
    })
  }
  
  // Clear specific notification
  async clearNotification(tag) {
    if (this.registration) {
      const notifications = await this.registration.getNotifications({ tag })
      notifications.forEach(notification => notification.close())
    }
    this.activeNotifications.delete(tag)
  }
  
  // Clear all notifications
  async clearAllNotifications() {
    if (this.registration) {
      const notifications = await this.registration.getNotifications()
      notifications.forEach(notification => notification.close())
    }
    this.activeNotifications.clear()
  }
}

// 6. Usage in your P2P components
// src/routes/chat/+page.svelte
<script>
  import { onMount } from 'svelte'
  import { browser } from '$app/environment'
  
  let peerConnection
  let messages = []
  
  onMount(() => {
    if (browser) {
      // Initialize your P2P connection
      initP2PConnection()
    }
  })
  
  function initP2PConnection() {
    // Your existing P2P setup code...
    
    // When you receive a message from a peer
    peerConnection.onmessage = (event) => {
      const message = JSON.parse(event.data)
      messages = [...messages, message]
      
      // Show notification if window is not focused
      if (document.hidden && window.notificationManager) {
        window.notificationManager.onPeerMessage(
          message, 
          peerConnection.peerId,
          peerConnection.peerName
        )
      }
    }
    
    // When a peer connects
    peerConnection.onopen = () => {
      if (window.notificationManager) {
        window.notificationManager.onPeerConnected(
          peerConnection.peerId,
          peerConnection.peerName
        )
      }
    }
    
    // When connection is lost
    peerConnection.onclose = () => {
      if (window.notificationManager) {
        window.notificationManager.onConnectionLost(
          peerConnection.peerId,
          peerConnection.peerName
        )
      }
    }
  }
  
  function sendMessage(text) {
    const message = {
      id: Date.now(),
      text,
      timestamp: new Date().toISOString(),
      sender: 'me'
    }
    
    peerConnection.send(JSON.stringify(message))
    messages = [...messages, message]
  }
</script>

<!-- Your chat UI here -->

// 7. Add TypeScript support (optional)
// src/app.d.ts
import 'vite-plugin-pwa/client'
import 'vite-plugin-pwa/info'

declare global {
  interface Window {
    notificationManager: import('$lib/notifications.js').P2PNotificationManager
  }
}

export {}