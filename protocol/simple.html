<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Free Association with GunDB</title>
    <script src="https://cdn.jsdelivr.net/npm/gun/gun.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/gun/sea.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/gun/lib/then.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/gun/lib/radix.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/gun/lib/radisk.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/gun/lib/store.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/gun/lib/rindexed.js"></script>
</head>

<body>
    <button onclick="say('hi')">say hi</button>
    <button onclick="say('bye')">say bye</button>
</body>

<script>
    const gun = Gun(["https://gun-manhattan.herokuapp.com/gun"]);
    const user = gun.user();
    const pair = await SEA.pair();
    // user.auth

    // public
    const players = gun.get('players')

    // user-space
    const userTrees = user.get('trees') // All of user's Trees (rootNodes) 
    const userNodes = user.get('nodes') // All a user's Nodes across all trees

    // tree-data (writing)
    const rootNode = userTrees.get(rootNodeId)

    function createNode(key, name, points, children, contributors, manualFulfillment) {
        return userNodes.get(key).put({
            name, owner: user, points, children, contributors, manualFulfillment
        })
    }

    function createTree(key, name, owner, points, children, contributors, manualFulfillment, capacities) {
        const rootNode = createNode(key, name, points, children, contributors, manualFulfillment, capacities)
        userTrees.get(key).put(rootNode)
    }

/*
-- TODO:

-- Questions to ask:
-- What data do we want to persist?

-- Public: gun
   -- all players: const players = gun.get('players')

-- User-Space: user  
     -- All of user's Trees (rootNodes) /trees : user.get('trees').put(rootNode)
     -- All a user's Nodes across all trees /nodes : user.get('nodes').put(node)

    -- Tree (rootNode) data:
     -- rootNode.get('capacities').put(capacitiy)
     -- rootNode.get('sharesOfGeneralFulfillment').get(rootNodeSoul).put()
     -- rootNode.get('providerShares').get(depth).put(Map)

-- What caches do we want to persist and which only make runtime calculations more efficient?

-- How often do we want to be doing certain calculations? Under what conditions?
   -- SharesOfGeneralFulfillment (Time-Complexity?)
   -- ProviderShares [1-5] (Time-complexity?) 

   -- What data do we want to subscribe to (.on), and which will we just fetch (.once)

-- Can we do without the Points type and just use Int?
-- newtype Points = Points Int deriving (Eq, Ord, Show)
-- getPoints (Points p) = p

-- We are not currently caching the mutual-recognition value itself
-- only the caching the derived normalized map?
-- Should we also cache/persist the mutual-values themselves?

-- What other unused types do we have?
*/

/*
OBS: A thing about map, is that it will actually store (in local storage in the browser) all the values it is iterating. If you are connecting to a public relay this might quickly overload your users with data they donâ€™t need.
*/

/*

But what do you do then, if you want to get some values from one node, but also some values from another node? Consider the following more real-world-like example:

gun.get("car").get("type").put({brand: "toyota", year: "2004"});
gun.get("car").get("miles_driven").put(12423);

function get_car(cb) {
    // ???
    cb( {type: {brand, year}, miles_driven} )
}

    function manfiestTree(cb) {
        //Using this-context to get gun node instead of values. The following will NOT work with arrow-functions as we loose the this-context because of the way these are bound.
        userTrees.get(key).once(function(tree){
        const miles_driven = tree.miles_driven;
        this.get("children").once(function(children){ // important line.
          const brand = children.brand;
          const year = children.year;

          cb( {type: {brand, year}, miles_driven} )
      });
  });
}
// I recommend using the last approach because it preserves the this-context throughout and can be easily incorporated into standardized classes as we will see later. But for now, the three approaches should serve as a way to build understanding of the inner workings of gun.


</script>